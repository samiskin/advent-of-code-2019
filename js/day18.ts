//---------------------------------------------------------------------------------
import { _, eq, neq, gt, lt, range, range2, nRange, print, printGrid, hash, timeout, clamp, gcd, lcm, getNeighbors, bfs, createProgram, runProgram, getMapPoints, addPos, hashToPoint, PriorityQueue, backtrack, bfsPq } from "./utils";
console.clear();
console.log("\n");
//---------------------------------------------------------------------------------

const input = `
#################################################################################
#.#.......#.................#.D...#.....#.........#.......#.#...#.......#.....V.#
#.#.#####.#####.###.#######M###.#.#.###########H#.###.#.#.#.#.#.###.###.#######.#
#.#...#.....N.#.#...#...#...#...#.#.....#.....#.#...#.#.#...#.#...#.#.#.......#.#
#.###.#######.###.###.###.###.###.###.#.#.###.#.###.#.#.#####.###.#.#.#######.#.#
#...#...#.........#.#.....#.....#...#.#.#.#...#.#...#.#...#...#.....#.......#...#
#.#.###L###########Q#.#######.#.###.###.#.###.#.#.#######.#.#.#######.#.###.###.#
#.#...#t..........#.#.#.....#.#.#...#..o#...#...#.......#.#.#.#.....#.#.#...#...#
#.#.#############.#.#.#.###.###.#.###.#.###.###########.#.#.###.###.#.#.#####.###
#.#.#.........#...#...#.#.......#.#...#.#...#.........#.#.#.....#...#.#.U.#...#.#
#.#.#.#######.#.###.###W#########.#.###.#.#########.#.#.#.#######.#######.#.###.#
#j#...#.....#.#.#...#.....#.....#...#.#.#...#.....#.#.#...#.......#.....#.#.#...#
#.#########.#.#T#.###.###.#.#.#.#####.#.#.#.#.###.#.#.#.###.#######.#.#.#.#.###.#
#...#.......#.#x#...#.#.#.#.#.#.#k..#...#.#.....#.#.#.#.#...#.....#.#.#...#...#.#
###.###.#####.#.###.#.#.#.###.#.#.#.#.###.#######.#.#.#.#.###.###.#.#.###.###.#.#
#.#.E.#.#.....#.#...#...#z..#.#.#.#.#...#.#b......#.#...#.....#...#.#.#...#...#.#
#.###.#.#.###.#.###.#######.#.#.###.###.###.#######.###########.#####.#.###.###.#
#...#...#.#v..#...#...#.....#.#.......#.#...#.....#.#.....#...#.#.....#.#...#...#
#.#.###.#.#.#####.###.#.#####.#########.#.###.###.#.#####.#.#.#.#.#.#####J###.###
#.#.#...#.#.#...#.#.....#.#...........#.#.#.#.#.#...#...#.#.#...#.#.......#.....#
#.###.###.#.#.#.#.#######.#.#########.#.#P#.#.#.#####.#.#.#.#####.#############.#
#.#...#.#.#.#.#f#...#.#.#...#...#...#.#.#.#...#...#...#...#.#.#.......#...#.....#
#C#.###.#.###.#.###.#X#.#.#####.#.#.#.#.#.#.###.#.#.#######.#.#######.#.#.#.###.#
#...#...#.....#...#...#...#.....#.#...#.#.#...#.#...#.....#.#...#.....#.#...#...#
#.#####.#########.#####.###.#.#.#.#.###.#.###.#.#####.###.#.###.###.###.#########
#.#...#.....#...#.....#...#.#.#.#.#.#...#...#...#...#.#.......#...#.#...#.......#
#.#.#.###.#.#.#.###.#####.#.#.###.###.#####.#.###.#.#.###########.#.#.###.#####.#
#...#...#.#.#.#...#.....#.#.#.#...#...#.#...#.#...#.#.#.....#...#.#.#...#.....#.#
#######.#.###.###.###.###.###.#.###.###.#.###.#.###.#.#.###.#.#.#.#.###.#####.#.#
#.....#.#.#...#.#.#...#...#...#.....#...#.#...#.#...#...#.#...#...#...#...#...#e#
#.#####.#.#.###.#.#.###.###.#.#########.#.#.###.#.#######.###########.#.###.###.#
#.Y.....#.......#.#.....#...#.#.........#.#.#...#.........#.........#.#.......#.#
#.###############.#######.###.###.###.###.#.#.#########.###.#####.#.#.#######.#.#
#.....#.........#.........#.#...#.#.#...#.#.#.........#.....#.#...#.#.....#...#.#
#####.#.#.#####.#####.#####.###.#.#.###.#.###########.#######.#.###.#####.#####.#
#.#...#.#.#...#......s#.#.......#.....#.#.#.........#.#.......#.#.....#...#.....#
#.#.#####.#.#.#########.#.#############.#.#.#####.#.#.#####.###.#####.#.###.###.#
#.#.....#.#.#.......#...#.#...........#.#.#.#...#.#.#...#...#...#...#.#.#...#...#
#.#####.#.#.#.#######.#.#.###.#######.#.#.#.###.#.#####.#.#.#.###.#.###.#.###.###
#.........#.#.........#.......#.................#.........#.#.....#.......#.....#
#######################################.@.#######################################
#.....#.....#.........#.....#.................#.....#.......#.........#..y....#.#
#.###.#.#.#.#.#######.#.###.#.###.#####.#.###.###.###.###.#.###.#.###.#.#####.#.#
#...#.#.#.#...#.....#.#...#.#...#.#...#.#...#.....#...#...#...#.#.#...#.#...#...#
###.#.###.#########.#.###.#.###.#.#.#.#.###.#####.#.###.#####.#.#.#.###.#.#.###.#
#...#.#...#...#.....#.#...#.....#.#.#...#...#...#.#.#...#...#.#.#.#.....#.#..c#.#
#.###.#.###.#.#.###.#.###########.###.###.###.#.###.#.###.#.#.###.#######.###.#.#
#.#.#...#...#...#...#.......#...#...#.#.#.#...#.....#.#.#.#.#...#...#...#.#.#...#
#.#.#####.#######.#########.#.#.###.#.#.#.#.#########.#.#.#.###.###.#.#.#.#.#####
#.#.......#.....#.......#...#.#.#...#...#p..#.........#.#.#...#.....#.#.#...#...#
#.###.###.#.###.#######.#.###.#.#.#####.#####.#########.#.###.#######.#.###.###.#
#...#...#.....#.#.......#.....#.#.#.....#.....#.........#...#.........#...#...#.#
#.#.#####.#####.#.#############.#.#####.#.#####.#######.###.#####.#.#####.###.#.#
#.#.....#.#.....#.....#.......#.#.....#.#...#...#.....#...#...#.#.#.#...#...#.#.#
#######.#.#.###########.#####.#.#####.#.#.#.###.#.###.#.#####.#.#.###.#.#####.#.#
#.......#.#..u..#.......#.....#...#...#.#.#...#.#.#.#.#.........#.....#.......#.#
#.###########.#.#.#######.#.#####.#.###.#####.#.#.#.#.#########.###############.#
#.G.#...#...#.#...#.......#.#.....#.#...#.....#.#.#.#.........#.....#...#.......#
#.#.#.#.#.#I#.#####.#########.#####.#####.#######.#.#########.#####.#.#.###.#.#.#
#.#...#...#.#.#...#.........#...#.......#.........#.......#...#...#...#...#.#.#.#
#.#########.#.###.#####.###.###.#.#####.###############.###.#####.#######.###.#.#
#.#...#.....#.....#...#.#...#...#...#...#.....#.......#.#...#...#.......#...F.#g#
#.###.#.#########.#.###.#.###.#####B#.#.###.#.###.###.#.#.#####.#####.#########.#
#.....#.#...#...#.#.#...#...#.#.....#.#.#...#...#.#.#.#.#.#.....#.....#....r#...#
#.#####.#.#R#.#.###.#####.#.#.#.#####.#.#.#####.#.#.#.#.#.#.#####.#####.#.#.#.###
#.#...#...#...#...#.....#.#.#.#.....#.#.#.....#...#.....#.#.#.....#.....#.#.#...#
###.#.###########.#####.#.#.#.#######.#.#####.#.#######.#.#.###.###.#####.#####.#
#...#.#...#...#.......#.#.#.#.......#.#.#.....#n#.....#l#...#...#...#...#...#...#
#.###.#A#.#.#.#.#####.#.###.#######.#.#.#.#######.###.#######.#.#.#####.###.#.###
#...#...#...#.#.#.#...#...#.....#...#.#.#...#...#.#.#.........#.#.#...#...#.#.#.#
###.#########.#.#.#.#####.#####.#.###.#.###.#Z#.#.#.#####.#.#####.#.#.#.###.#.#.#
#...#.....#.#...#.....#...#...#.#...#.#.#...#.#.#.....#...#.#...#...#.#.#...#..i#
#.###.###.#.#####.#####.###.#.#.###.#.#.#.###.#.#.#####.###.#.#.#####K#.#.#####.#
#.....#.#.#.......#.....#...#...#...#.#.#q#...#...#...#...#.#.#.....#...#.......#
#.#####.#.#####.###.#####.#.###.#.###.###.#.#######.#.###.#.#.#.#######.#########
#.#...#.#.....#...#...#...#.#...#.#.#...#...#...#.#d#.....#.#.#..a......#.....#.#
#.#.#.#.#####.#######.#.###.###.#.#.#.#.#.###.#.#.#.#########.###########.#.#.#.#
#...#.#..w..#.#.....#.#.#.#...#.#.#...#.#.#...#..m#.#.....#...#.....#...#.#.#...#
#####.#####.#.#.###.#.#.#.###.###.#####S#.###.###.#.#.###.#.###.###.#.#.###.###.#
#...........#.....#...#.....#......h....#.....#...#.O...#.......#.....#.....#...#
#################################################################################
`;
const inputTest = `
#################
#i.G..c.#.e..H.p#
#######.#.#######
#j.A..b...f..D.o#
#######.@.#######
#k.E..a...g..B.n#
#######.#.#######
#l.F..d.#.h..C.m#
#################
`;

const map: Record<string, string> = input
  .trim()
  .split("\n")
  .reduce(
    (fullMap, line, y) => ({
      ...fullMap,
      ...line
        .split("")
        .reduce((obj, char, x) => ({ ...obj, [hash([x, y])]: char }), {})
    }),
    {}
  );

const isKey = (char: string) => 'a' <= char && 'z' >= char;
const isDoor = (char: string) => 'A' <= char && 'Z' >= char;
const keyPoints = getMapPoints(map).filter(([x, y]) => isKey(map[hash([x, y])]));
const findChar = (char: string) => getMapPoints(map).filter(([x, y]) => map[hash([x, y])] === char);

type Graph = Record<string, Record<string, {
  pos: [number, number],
  key: string,
  dist: number,
  requiredKeys: Array<string>,
}>>

/**
 * Generate a graph that stores the distances from each key to every other key as
 * well as the necessary keys to be able to traverse that edge
 */
const buildGraph = (starts: Array<[number, number]>) => starts.reduce((grid, pos) => {
  grid[hash(pos)] = {};
  const data = bfs({ map, start: pos, isWall: (v) => v === '#' });
  for (let otherKey of keyPoints.filter((p) => p[0] !== pos[0] || p[1] !== pos[1])) {
    if (!data[hash(otherKey)]) continue;
    const path = backtrack(data, otherKey);
    const doors = path.filter((pos) => isDoor(map[hash(pos)]));
    grid[hash(pos)][hash(otherKey)] = {
      pos: otherKey,
      key: map[hash(otherKey)],
      dist: data[hash(otherKey)].length,
      requiredKeys: doors.map((pos) => map[hash(pos)].toLowerCase()),
    };
  }
  return grid
}, {})

type State = {
  positions: Array<[number, number]>,
  dist: number;
  keys: Array<string>;
}

const hashState = ({ positions, keys }: State) => `${JSON.stringify(positions)} | ${JSON.stringify(keys)}`;
const compareState = (a: State, b: State) => PriorityQueue.defaultCompare(a.dist, b.dist);

const getNeighborStates = (graph: Graph, { positions, keys, dist }: State): State[] => {
  const keyset = new Set(keys);
  return positions.reduce((neighbors, pos, i) => {
    const allNeighbors = graph[hash(pos)];
    const accessibleNeighbors = Object.values(allNeighbors)
      .filter(({ key }) => !keyset.has(key))
      .filter(({ requiredKeys }) => requiredKeys.every((k: string) => keyset.has(k)))
    return neighbors.concat(accessibleNeighbors.map((neighbor) => {
      const newPositions = [...positions];
      newPositions.splice(i, 1, neighbor.pos);
      return {
        positions: newPositions,
        dist: dist + neighbor.dist,
        keys: keys.concat([neighbor.key]).sort(),
      }
    }));
  }, []);
}

// ----------

const startPosP1 = findChar('@')[0];
const startStateP1 = { positions: [startPosP1], dist: 0, keys: [] };
const graph: Graph = buildGraph(keyPoints.concat([startPosP1]));

const targetP1 = bfsPq({
  start: startStateP1,
  hashState: hashState,
  getNeighbors: (...args) => getNeighborStates(graph, ...args),
  isGoal: ({ keys }) => keys.length === keyPoints.length,
  compare: compareState,
});

console.log(targetP1.dist);
console.log("done p1");

// ----------

const adjacentToStart = getNeighbors(startPosP1).map(hash);
const diagToStart = _.difference(
  getNeighbors(startPosP1, true).map(hash),
  adjacentToStart
);
adjacentToStart.forEach(posHash => (map[posHash] = "#"));
diagToStart.forEach(posHash => (map[posHash] = "@"));

// ----------

const startPosP2 = findChar('@');

const startStateP2: State = { positions: startPosP2, dist: 0, keys: [] };
const graphP2: Graph = buildGraph(keyPoints.concat(startPosP2));


const targetP2 = bfsPq({
  start: startStateP2,
  hashState: hashState,
  getNeighbors: (...args) => getNeighborStates(graphP2, ...args),
  isGoal: ({ keys }) => keys.length === keyPoints.length,
  compare: compareState,
});

console.log(targetP2.dist);
console.log("done p2");
